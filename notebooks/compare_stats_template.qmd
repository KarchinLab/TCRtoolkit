---
title: "Comparative bulk T Cell Repertoire statistics"
format:
  html: 
    theme: flatly
    toc: true
    toc_depth: 3
    code-fold: true
    embed-resources: true
    number-sections: true
    grid:
      body-width: 1000px
      margin-width: 300px

jupyter: python3
---

This notebook was generated via the `bulk-tcrseq` pipeline developed at Johns Hopkins for use by BTC scientists. 

# Report Setup

Below is information about the environment and parameters used to generate this report; if you are more computationally inclined and curious about how the report is set up then ...

```{python, echo=false}
#| tags: [parameters]
#| echo: false

## 2. Pipeline Parameters
#Default inputs are overwritten at the command line in `modules/local/plot_sample.nf`
workflow_cmd='<command used to run the pipeline>'
project_name='path/to/project_name'
project_dir='path/to/project_dir'
jaccard_mat='path/to/jaccard_mat.csv'
sorenson_mat='path/to/sorenson_mat.csv'
morisita_mat='path/to/morisita_mat.csv'
```

```{python}
#| tags: [setup]

# 1. Load Packages
import os
import datetime
import sys
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import plotly.express as px

# 2. Print Pipeline Information
print('Pipeline information and parameters:' + '\n')
print('Project Name:          ' + project_name)
print('Workflow command:      ' + workflow_cmd)
print('Pipeline Directory:    ' + project_dir)
print('Date and time:         ' + str(datetime.datetime.now()))

# 3. Importing custom plotting functions
## Plotting functions are defined in `bin/utility_functions.py`.
sys.path.append(project_dir + '/bin/')
from utility_functions import TicTocGenerator, tic, toc
TicToc = TicTocGenerator()

# 4. Importing data
## 4a. jaccard similarity matrix
jaccard_df = pd.read_csv(jaccard_mat, sep=',', header=0, index_col=0)

## 4b. sorenson similarity matrix
sorenson_df = pd.read_csv(sorenson_mat, sep=',', header=0, index_col=0)

## 4c. morisita similarity matrix
morisita_df = pd.read_csv(morisita_mat, sep=',', header=0, index_col=0)
```

# Analysis

## Jaccard Similarity Matrix

```{python}
import scipy.cluster.hierarchy as sch
import scipy.spatial.distance as ssd
from plotly.figure_factory import create_dendrogram
import plotly.graph_objects as go

tic()

# Assuming jaccard_mat is a pandas DataFrame
jaccard_numeric = jaccard_df.apply(pd.to_numeric, errors='coerce')

# Log scale the data
jaccard_numeric = np.log10(jaccard_numeric)

# Replace non-numeric values with NaN
jaccard_numeric = jaccard_numeric.where(pd.notnull(jaccard_numeric), np.nan)

# Assuming jaccard_numeric is your DataFrame
sns_cluster = sns.clustermap(jaccard_numeric)

# Get the clustered data
clustered_data = jaccard_numeric.iloc[sns_cluster.dendrogram_row.reordered_ind, sns_cluster.dendrogram_col.reordered_ind]

# Create a heatmap with plotly
fig = go.Figure(data=go.Heatmap(
                   z=clustered_data,
                   x=clustered_data.columns,
                   y=clustered_data.index,
                   coloraxis="coloraxis"))

fig.update_layout(
    title='Jaccard Similarity Matrix',
    xaxis_title='Sample ID',
    yaxis_title='Sample ID',
    autosize=False,
    width=950,
    height=950,
    margin=dict(l=100, r=100, b=100, t=100, pad=2),
    coloraxis=dict(colorscale='Blues', colorbar=dict(title="Log Scale"))
)

fig.show()

toc()
## Jaccard Similarity Matrix (Clustered)


# Assuming mat is your nxn numpy matrix
distArray = ssd.squareform(ssd.pdist(jaccard_numeric))

# Perform hierarchical clustering
Z = sch.linkage(distArray, method='average')

# Create a dendrogram
dendro = create_dendrogram(Z, orientation='bottom')

# Create a heatmap
heatmap = go.Heatmap(
    x=dendro['layout']['xaxis']['tickvals'],
    y=dendro['layout']['yaxis']['tickvals'],
    z=jaccard_numeric,
    colorscale='Blues'
)

# Combine the dendrogram and heatmap into one figure
fig = go.Figure(data=[dendro['data'][0], heatmap])

# Update the layout
fig.update_layout(
    title='Hierarchical Clustering',
    width=800,
    height=800,
    autosize=False,
    margin=dict(l=100, r=100, b=100, t=100, pad=2)
)

fig.show()
```
