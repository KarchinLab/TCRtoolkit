---
title: "Sample Level T Cell Repertoire statistics"
format:
  html: 
    theme: flatly
    toc: true
    toc_depth: 3
    code-fold: true
    embed-resources: true
    number-sections: true
    smooth-scroll: true
    grid:
      body-width: 1000px
      margin-width: 300px

jupyter: python3
---

Thank you for using `TCRtoolkit`. This report, generated from your provided data, presents sample level T cell repertoire statistics. Each plot includes a description, relevant formulas, and biological relevance. However, *specific* biological interpretation is up to the user.

As this pipeline is still in beta, **please report any issues or suggestions for improvement to:** dbracci1 [at] jh [dot] edu.

# Report Setup

```{python, echo=false}
#| tags: [parameters]
#| echo: false

workflow_cmd='<command used to run the pipeline>'
project_name='path/to/project_name'
project_dir='path/to/project_dir'
sample_table='path/to/sample_table.csv'
sample_stats_csv='path/to/sample_stats.csv'
v_family_csv='path/to/v_family.csv'
```

```{python}
#| tags: [setup]
#| warning: false

# 1. Load packages
from IPython.display import Image
import os
import datetime
import sys
import pandas as pd
import math
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import plotly.express as px
import plotly.graph_objects as go

# 2. Print pipeline information
print('Project Name:          ' + project_name)
print('Workflow command:      ' + workflow_cmd)
print('Pipeline Directory:    ' + project_dir)
print('Date and time:         ' + str(datetime.datetime.now()))

# 3. Importing custom plotting functions
sys.path.append(project_dir + '/bin/')
from utils import TicTocGenerator, tic, toc
TicToc = TicTocGenerator()

# 4. Loading Data
tic()

## reading combined repertoire statistics
df = pd.read_csv(sample_stats_csv, sep=',', header=0, 
                 names=['sample_id', 'patient_id', 'timepoint', 'origin',
                        'num_clones', 'num_TCRs', 'simpson_index', 'simpson_index_corrected', 'clonality',
                        'num_in', 'num_out', 'num_stop', 'pct_prod', 'pct_out', 'pct_stop', 'pct_nonprod',
                        'cdr3_avg_len', 'num_convergent', 'ratio_convergent'])
print('-- Imported sample_stats_csv as `df`...')

## reading sample metadata
meta = pd.read_csv(sample_table, sep=',', header=0, index_col=None,
                   names=['sample_id', 'file_path', 'patient_id', 'timepoint', 'origin'])
print('-- Imported sample_table as `meta`...')

## reading V gene family usage 
v_family = pd.read_csv(v_family_csv, sep=',', header=0, index_col=None,
                       names=['patient_id', 'timepoint', 'origin', 'TCRBV01', 
                              'TCRBV02', 'TCRBV03', 'TCRBV04', 'TCRBV05', 'TCRBV06',
                              'TCRBV07', 'TCRBV08', 'TCRBV09', 'TCRBV10', 'TCRBV11',
                              'TCRBV12', 'TCRBV13', 'TCRBV14', 'TCRBV15', 'TCRBV16',
                              'TCRBV17', 'TCRBV18', 'TCRBV19', 'TCRBV20', 'TCRBV21',
                              'TCRBV22', 'TCRBV23', 'TCRBV24', 'TCRBV25', 'TCRBV26',
                              'TCRBV27', 'TCRBV28', 'TCRBV29', 'TCRBV30'])
v_family = v_family.sort_values(by=['patient_id', 'timepoint'])
print('-- Imported v_family_csv as `v_family`...')

toc()


```

# Sample Statistics

Below are plots showing sample level T cell repertoire statistics. Each plot has a description and formulas used to calculate the metric shown.

## Number of clones

```{python}
timepts = df.timepoint.unique().tolist()
timepts.sort()
fig = px.box(df, 
             x = 'timepoint', 
             y='num_clones', 
             color='origin',
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 1. Number of clones across timepoints.** Here, we define a clone as a T cell with a unique CDR3 amino acid sequence. The number of clones is shown on the y-axis and 'origin_timepoint' is shown on the x-axis. 

## Clonality

```{python}
fig = px.box(df, 
             x = 'timepoint', 
             y='clonality', 
             color='origin', 
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 2. The clonality of samples across timepoints.** Clonality is a measure of T cell clonal expansion and reflects the degree to which the sample is dominated by 1 or more T cell clones. Clonality is calculated via: 

$$Clonality = 1 - \frac {H} {\log_{2} N} \quad\text{,}\quad H = -\sum\limits_{i=1}^N p_i \log_{2}{p_i}$$

 where $H$ is the Shannon entropy of a given sample, $N$ is the number of unique TCRs in the sample, and $p_i$ is the frequency of the $i$ th unique TCR in the sample. 

## Simpson Index

```{python}
fig = px.box(df, 
             x = 'timepoint', 
             y='simpson_index_corrected', 
             color='origin',
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 3. Corrected Simpson Index.** The Simpson Index is a measure of diversity that takes into account the number of clones and the relative abundance of each clone in a sample. The corrected Simpson Index, $D$, is calculated as: 

$$D = \sum\limits_{i=1}^N \frac {p_i(p_i - 1)} {T(T - 1)} \quad\text{,}\quad T = \sum\limits_{i=1}^N p_i$$

Where $N$ is the number of unique TCRs in the sample, $p_i$ is the frequency of the $i$ th unique TCR in the sample, and $T$ is the total number of T Cells counted in the sample. 

## Percent of productive TCRs

```{python}
fig = px.box(df, 
             x = 'timepoint', 
             y='pct_prod', 
             color='origin', 
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 4. Percent of productive TCRs.** A productive TCR is a DNA/RNA sequence that can be translated into a protein sequence, i.e. it does not contain a premature stop codon or an out of frame rearrangement. The percent of productive TCRs is calculated as: 

$$ Percent \text{ } productive \text{ } TCRs = \frac P N $$

where $P$ is the number of productive TCRs and $N$ is the total number of TCRs in a given sample. 

## Average CDR3 Length

```{python}
fig = px.box(df, 
             x = 'timepoint', 
             y='cdr3_avg_len', 
             color='origin', 
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 5. Average CDR3 Length** The average length of the CDR3 region of the TCR. The CDR3 region is the most variable region of the TCR and is the region that determines antigen specificity.

## TCR Convergence

```{python}
fig = px.box(df, 
             x = 'timepoint', 
             y='ratio_convergent', 
             color='origin', 
             template='simple_white',
             points='all', hover_data=['sample_id'],
             category_orders={'timepoint': timepts})
fig.show()
```

**Figure 6. TCR Convergence** The ratio of convergent TCRs to total TCRs. A convergent TCR is a TCR that is generated via 2 or more unique nucleotide sequences via codon degeneracy. Convergence can be seen as a proxy for selection.

# Gene Family Usage

## V gene family usage

The V gene family usage of the TCRs in each sample is shown in the plots below. The x-axis shows the timepoint collected for each individual, and the y-axis shows the proportion of TCRs that use each V gene family.

The equation for calculating the proportion of TCRs that use a given V gene family is:

$$n_gk$$

```{python}


## calculate v gene usage proportion from raw counts
v_family_proportion = v_family.iloc[:, :3].copy()
v_family_proportion[v_family.columns[3:]] = v_family.iloc[:, 3:].div(v_family.iloc[:, 3:].sum(axis=1), axis=0)
v_family_proportion_long = pd.melt(v_family_proportion, id_vars=['patient_id', 'timepoint', 'origin'], value_vars=v_family.columns[3:], var_name='v_gene', value_name='proportion')

## choose color gradient for each v gene (using https://colordesigner.io/gradient-generator)
colors = ["#fafa70","#fdef6b","#ffe566","#ffda63","#ffd061","#ffc660","#ffbb5f","#fdb15f","#fba860","#f79e61","#f39562","#ef8c63","#e98365","#e37b66","#dd7367","#d66b68","#ce6469","#c65e6a","#bd576b","#b4526b","#ab4c6b","#a1476a","#974369","#8c3e68","#823a66","#773764","#6d3361","#62305e","#572c5a","#4d2956"]

## loop through all patients and plot stacked bar chart of v_family
## (code adapted from https://www.moritzkoerber.com/posts/plotly-grouped-stacked-bar-chart/)
for patient in v_family_proportion_long.patient_id.unique().tolist():
    current = v_family_proportion_long[v_family_proportion_long.patient_id == patient]
    fig = go.Figure()
    fig.update_layout(
        template="simple_white",
        title_text="Patient: " + str(patient),
        xaxis=dict(title_text="timepont"),
        yaxis=dict(title_text="proportion"),
        barmode="stack",
    )

    for g, c in zip(current.v_gene.unique(), colors):
        plot_df = current[current.v_gene == g]
        fig.add_trace(
            go.Bar(x=[plot_df.timepoint, plot_df.origin], 
                   y=plot_df.proportion, name=g, marker_color=c),
        )

    fig.show()
```

# Environment

```{python}
#| tags: [environment]

!mamba list
```